# QR Code Generation - Remaining Implementation Steps

이 문서는 QR Decompile 프로젝트에서 남은 구현 단계들을 정리합니다. 현재 Step 1(데이터 분석)과 Step 2(데이터 인코딩)가 완료되었으며, 다음 단계들을 순차적으로 구현해야 합니다.

## 완료된 단계

### ✅ Step 1: 데이터 분석 (Data Analysis)
- 문자 타입 감지 (숫자/영숫자/바이트/한자)
- 최적 인코딩 모드 선택
- 최소 QR 버전 계산
- 실시간 분석 UI

### ✅ Step 2: 데이터 인코딩 (Data Encoding)
- 모드별 인코딩 (숫자/영숫자/바이트)
- 비트 스트림 생성 (모드 지시자, 문자 카운트, 데이터)
- 종단자 및 패딩 처리
- 비트 스트림 시각화

## 남은 구현 단계

### ✅ Step 3: 에러 정정 (Error Correction) - **완료**
**구현 완료**: Reed-Solomon 에러 정정 코드 생성

#### 구현된 기능:
1. **Reed-Solomon 알고리즘**
   - ✅ GaloisField256 클래스로 캡슐화된 GF(256) 연산
   - ✅ 생성 다항식 구현 (ISO 표준 준수)
   - ✅ 다항식 나눗셈을 통한 에러 정정 코드워드 생성
   - ✅ 블록 분할 처리 및 인터리빙

2. **에러 정정 레벨별 처리**
   - ✅ 전체 40개 버전 EC 블록 테이블 (ISO/IEC 18004 표 13-22)
   - ✅ L, M, Q, H 레벨별 코드워드 수 계산
   - ✅ 다중 그룹 블록 구조 지원

3. **아키텍처 개선**
   - ✅ 단계별 폴더 구조 (`error-correction/`)
   - ✅ 상수 통합 (`shared/consts.ts`)
   - ✅ 전역 shared 모듈 구조
   - ✅ 타입 안전성 강화

4. **UI 컴포넌트**
   - ✅ `ErrorCorrectionColumn` 생성
   - ✅ 블록별 데이터/EC 코드워드 시각화
   - ✅ 인터리빙된 최종 결과 표시

5. **테스트**
   - ✅ 16개 유닛 테스트 작성 및 통과
   - ✅ Reed-Solomon, 인터리빙, 블록 처리 검증

---

### 🔄 Step 4: 메시지 구성 (Message Construction)
**목표**: 데이터와 에러 정정 코드워드 인터리빙

#### 구현 요소:
1. **블록 인터리빙**
   - 데이터 블록과 에러 정정 블록 분리
   - 코드워드 순서 재배열
   - 최종 메시지 시퀀스 생성

2. **나머지 비트 처리**
   - 버전별 나머지 비트 추가 (0 패딩)
   - 표 1의 나머지 비트 참조

3. **UI 컴포넌트**
   - 인터리빙 과정 시각화
   - 블록 구조 표시
   - 최종 메시지 순서 확인

#### 참조 문서:
- ISO/IEC 18004 Section 8.6 (line 1289-1334)

---

### 🔄 Step 5: 모듈 배치 (Module Placement)
**목표**: QR 매트릭스에 데이터 배치

#### 구현 요소:
1. **기능 패턴 배치**
   - 파인더 패턴 (Finder Patterns)
   - 분리자 (Separators)
   - 타이밍 패턴 (Timing Patterns)
   - 얼라인먼트 패턴 (Alignment Patterns)

2. **데이터 모듈 배치**
   - 지그재그 패턴으로 데이터 배치
   - 기능 패턴 영역 회피
   - 비트-모듈 매핑

3. **UI 컴포넌트**
   - 매트릭스 구조 시각화
   - 패턴별 색상 구분
   - 데이터 배치 순서 표시

#### 참조 문서:
- ISO/IEC 18004 Section 7.3 (line 363-416): 심벌 구조
- ISO/IEC 18004 Section 8.7 (line 1335-1426): 모듈 배치

---

### 🔄 Step 6: 마스킹 (Masking)
**목표**: 최적 마스크 패턴 적용

#### 구현 요소:
1. **8가지 마스크 패턴**
   - 마스크 0-7 패턴 구현
   - 데이터 모듈에만 적용
   - 기능 패턴 보호

2. **마스크 평가**
   - 4가지 평가 규칙 구현
   - 패널티 점수 계산
   - 최적 마스크 선택

3. **UI 컴포넌트**
   - 8가지 마스크 결과 미리보기
   - 평가 점수 표시
   - 최적 마스크 선택 과정

#### 참조 문서:
- ISO/IEC 18004 Section 8.8 (line 1427-1516): 마스킹

---

### 🔄 Step 7: 포맷 정보 (Format Information)
**목표**: QR 코드 완성

#### 구현 요소:
1. **포맷 정보 생성**
   - 에러 정정 레벨 + 마스크 패턴 인코딩
   - BCH 에러 정정 코드 생성
   - 포맷 정보 배치

2. **버전 정보** (버전 7-40)
   - 버전 정보 인코딩
   - BCH 에러 정정 코드 생성
   - 버전 정보 배치

3. **최종 QR 코드**
   - 모든 단계 통합
   - 표준 준수 검증
   - 완성된 QR 코드 출력

#### 참조 문서:
- ISO/IEC 18004 Section 8.9 (line 1517-1614): 포맷 정보
- ISO/IEC 18004 Section 8.10 (line 1615+): 버전 정보

## 프로젝트 아키텍처 개선사항

### ✅ 코드 구조 재편성 완료
1. **단계별 폴더 구조**
   ```
   src/
   ├── qr/
   │   ├── analysis/            # 데이터 분석 (39 tests)
   │   ├── encoding/            # 데이터 인코딩 (20 tests)  
   │   ├── error-correction/    # 에러 정정 (16 tests)
   │   └── qrPipeline.ts       # 파이프라인 통합
   └── shared/                 # 전역 공유 모듈
       ├── types.ts           # QR 타입 정의
       ├── consts.ts          # QR 상수 통합
       └── ...utils.ts        # 유틸리티 함수들
   ```

2. **상수 및 유틸리티 분리**
   - `shared/types.ts`: 모든 QR 관련 타입 정의
   - `shared/consts.ts`: QR 상수 통합 (모드, 용량, 갈루아 필드 등)
   - `shared/`: 전역 유틸리티 함수들

3. **테스트 커버리지**: 총 75개 테스트 통과

## 구현 우선순위

### Phase 1: 핵심 알고리즘 (Step 3-4) - ✅ 완료
1. ✅ Reed-Solomon 에러 정정 구현
2. ✅ 메시지 인터리빙 구현  
3. ✅ 단위 테스트 작성 및 코드 구조 개선

### Phase 2: 매트릭스 생성 (Step 5-6)
1. 기능 패턴 배치
2. 데이터 모듈 배치
3. 마스킹 알고리즘

### Phase 3: 완성 및 최적화 (Step 7)
1. 포맷/버전 정보 추가
2. 전체 파이프라인 통합
3. 성능 최적화

## 기술적 고려사항

### 성능
- Reed-Solomon 계산 최적화
- 대용량 데이터 처리
- 실시간 UI 업데이트

### 코드 품질
- 각 단계별 단위 테스트
- 함수형 프로그래밍 스타일 유지
- 타입 안전성 보장

### 사용자 경험
- 각 단계별 시각적 피드백
- 실시간 변경사항 반영
- 교육적 가치 극대화

## 참고 자료

- **ISO/IEC 18004 표준**: `docs/KSXISO_IEC18004_KR.md`
- **빠른 참조**: `docs/QR_INDEX.md`
- **현재 구현**: `src/qr/` 디렉토리
- **테스트**: `src/qr/*.test.ts` 파일들

---

*이 문서는 QR Decompile 프로젝트의 로드맵을 제공하며, 각 단계의 구현 시 상세한 계획 수립과 ISO 표준 준수를 위한 가이드라인입니다.*